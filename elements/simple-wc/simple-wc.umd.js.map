{"version":3,"file":"simple-wc.umd.js","sources":["simple-wc.umd.js"],"sourcesContent":["/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, css, html } from \"lit-element/lit-element.js\";\n\n/**\n * `simple-wc`\n * `A simple web component wrapper to simplify consistent patterns of element creation`\n * @demo demo/index.html\n * @element simple-wc\n */\nfunction camelCaseToDash(key) {\n  return key.replace(/([A-Z])/g, g => `-${g[0].toLowerCase()}`);\n}\nexport function createSWC(swc) {\n  let MyComponent = class SWC extends LitElement {\n    /**\n     * HTMLElement\n     */\n    constructor() {\n      super();\n      for (let key in swc.callbacks) {\n        this[key] = swc.callbacks[key];\n      }\n      // internal var to access everywhere\n      // set the values from defaults\n      for (let key in swc.data.values) {\n        this[key] = swc.data.values[key];\n      }\n      // dynamically import depedencies\n      setTimeout(() => {\n        swc.deps.map(i => {\n          import(`../../${i}`);\n        });\n      }, 0);\n    }\n    static get tag() {\n      return swc.name;\n    }\n    /**\n     * LitElement render function\n     */\n    render() {\n      return swc.html(this, html);\n    }\n    /**\n     * LitElement style rendering\n     */\n    static get styles() {\n      return [\n        css`\n          /* this style helps ease FOUC w/ dynamic imports */\n          :host *:not(:defined) {\n            display: none;\n          }\n        `,\n        swc.css(this, css)\n      ];\n    }\n    /**\n     * LitElement / popular convention\n     */\n    static get properties() {\n      let props = {};\n      for (let key in swc.data.values) {\n        // set type\n        props[key] = {\n          type: typeof swc.data.values[key]\n        };\n        props[key].type =\n          props[key].type.charAt(0).toUpperCase() + props[key].type.slice(1);\n        // convert camel to attr name IF it doesnt match\n        let attr = camelCaseToDash(key);\n        if (attr !== key) {\n          props[key].attribute = attr;\n        }\n        // LitElement syntax\n        if (swc.data.reflect && swc.data.reflect.includes(key)) {\n          props[key].reflect = true;\n        }\n      }\n      return { ...super.properties, ...props };\n    }\n    /**\n     * Updated attribute / property callback\n     */\n    updated(changedProperties) {\n      if (super.updated) {\n        super.updated(changedProperties);\n      }\n      changedProperties.forEach((old, name) => {\n        if (swc.data.observe) {\n          swc.data.observe.forEach((value, key) => {\n            // we have something we are observing\n            if (value[0].includes(name)) {\n              let result;\n              // theres 1 value so pass new and old vlaue\n              if (value[0].length === 1) {\n                result = swc.callbacks[value[1]](this[value[0][0]], old);\n              } else {\n                // pass in all the current values looking off of this\n                let valueMap = [];\n                value[0].map(val => {\n                  valueMap.push(this[val]);\n                });\n                // spread the value map so we get the values populated as args correctly\n                result = swc.callbacks[value[1]](...valueMap);\n              }\n              // set the result to this value while also spreading\n              // array values to propagate data binding\n              // this only happens if we have a 3rd value which is what we are\n              // storing the result in otherwise the result is not used\n              if (value.length == 3) {\n                this[value[2]] = Array.isArray(result) ? [...result] : result;\n              }\n            }\n          });\n        }\n        // notify changes\n        if (swc.data.notify && swc.data.notify.includes(name)) {\n          // notify\n          this.dispatchEvent(\n            new CustomEvent(`${camelCaseToDash(name)}-changed`, {\n              detail: {\n                value: this[name]\n              }\n            })\n          );\n        }\n      });\n    }\n    /**\n     * Window events add and remove\n     * @param {String} status\n     */\n    __applyWinEvents(status) {\n      if (swc.events && swc.events.window) {\n        for (let eName in swc.events.window) {\n          window[`${status ? \"add\" : \"remove\"}EventListener`](\n            eName,\n            swc.callbacks[swc.events.window[eName]].bind(this)\n          );\n        }\n      }\n    }\n    /**\n     * LitElement shadow dom ready\n     */\n    firstUpdated() {\n      if (swc.events && swc.events.shadow) {\n        for (let target in swc.events.shadow) {\n          for (let eName in swc.events.shadow[target]) {\n            this.shadowRoot\n              .querySelector(target)\n              .addEventListener(\n                eName,\n                swc.callbacks[swc.events.shadow[target][eName]].bind(this)\n              );\n          }\n        }\n      }\n    }\n    /**\n     * HTMLElement connected element\n     */\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n      this.__applyWinEvents(true);\n    }\n    /**\n     * HTMLElement disconnected element\n     */\n    disconnectedCallback() {\n      this.__applyWinEvents(false);\n      if (super.disconnectedCallback) {\n        super.disconnectedCallback();\n      }\n    }\n    /**\n     * return HAX Schema for wiring to HAX\n     * @todo build this on the fly from swc\n     */\n    haxProperties() {\n      return {};\n    }\n  };\n  customElements.define(MyComponent.tag, MyComponent);\n  return MyComponent;\n}\n"],"names":["camelCaseToDash","key","replace","g","toLowerCase","swc","MyComponent","callbacks","data","values","setTimeout","deps","map","i","LitElement","name","css","this","props","type","charAt","toUpperCase","slice","attr","attribute","reflect","includes","html","changedProperties","forEach","old","observe","value","result","length","_this2","valueMap","val","push","Array","isArray","notify","dispatchEvent","CustomEvent","detail","status","events","window","eName","bind","shadow","target","shadowRoot","querySelector","addEventListener","__applyWinEvents","customElements","define","tag"],"mappings":"o0EAYA,SAASA,EAAgBC,UAChBA,EAAIC,QAAQ,WAAY,SAAAC,oBAASA,EAAE,GAAGC,6BAExC,SAAmBC,OACpBC,qCAMK,IAAIL,oIAAOI,EAAIE,YACbN,GAAOI,EAAIE,UAAUN,OAIvB,IAAIA,KAAOI,EAAIG,KAAKC,SAClBR,GAAOI,EAAIG,KAAKC,OAAOR,UAG9BS,WAAW,WACTL,EAAIM,KAAKC,IAAI,SAAAC,0BACKA,OAEjB,2PAnB6BC,sDAsBzBT,EAAIU,0CAYJ,CACLC,WAMAX,EAAIW,IAAIC,KAAMD,+CAOZE,EAAQ,OACP,IAAIjB,KAAOI,EAAIG,KAAKC,OAAQ,CAE/BS,EAAMjB,GAAO,CACXkB,OAAad,EAAIG,KAAKC,OAAOR,KAE/BiB,EAAMjB,GAAKkB,KACTD,EAAMjB,GAAKkB,KAAKC,OAAO,GAAGC,cAAgBH,EAAMjB,GAAKkB,KAAKG,MAAM,OAE9DC,EAAOvB,EAAgBC,GACvBsB,IAAStB,IACXiB,EAAMjB,GAAKuB,UAAYD,GAGrBlB,EAAIG,KAAKiB,SAAWpB,EAAIG,KAAKiB,QAAQC,SAASzB,KAChDiB,EAAMjB,GAAKwB,SAAU,sYAGQP,gDAtC1Bb,EAAIsB,KAAKV,KAAMU,wCA2ChBC,2FAEUA,GAEhBA,EAAkBC,QAAQ,SAACC,EAAKf,GAC1BV,EAAIG,KAAKuB,SACX1B,EAAIG,KAAKuB,QAAQF,QAAQ,SAACG,EAAO/B,MAE3B+B,EAAM,GAAGN,SAASX,GAAO,KACvBkB,KAEoB,IAApBD,EAAM,GAAGE,OACXD,EAAS5B,EAAIE,UAAUyB,EAAM,IAAIG,EAAKH,EAAM,GAAG,IAAKF,OAC/C,OAEDM,EAAW,GACfJ,EAAM,GAAGpB,IAAI,SAAAyB,GACXD,EAASE,KAAKH,EAAKE,MAGrBJ,KAAS5B,EAAIE,WAAUyB,EAAM,YAAOI,GAMlB,GAAhBJ,EAAME,SACRC,EAAKH,EAAM,IAAMO,MAAMC,QAAQP,KAAcA,GAAUA,MAM3D5B,EAAIG,KAAKiC,QAAUpC,EAAIG,KAAKiC,OAAOf,SAASX,IAE9CoB,EAAKO,cACH,IAAIC,sBAAe3C,EAAgBe,eAAiB,CAClD6B,OAAQ,CACNZ,MAAOG,EAAKpB,kDAWP8B,MACXxC,EAAIyC,QAAUzC,EAAIyC,OAAOC,WACtB,IAAIC,KAAS3C,EAAIyC,OAAOC,OAC3BA,iBAAUF,EAAS,MAAQ,2BACzBG,EACA3C,EAAIE,UAAUF,EAAIyC,OAAOC,OAAOC,IAAQC,KAAKhC,iDAS/CZ,EAAIyC,QAAUzC,EAAIyC,OAAOI,WACtB,IAAIC,KAAU9C,EAAIyC,OAAOI,WACvB,IAAIF,KAAS3C,EAAIyC,OAAOI,OAAOC,QAC7BC,WACFC,cAAcF,GACdG,iBACCN,EACA3C,EAAIE,UAAUF,EAAIyC,OAAOI,OAAOC,GAAQH,IAAQC,KAAKhC,0JAa1DsC,kBAAiB,uDAMjBA,kBAAiB,yJAUf,+CAGXC,eAAeC,OAAOnD,EAAYoD,IAAKpD,GAChCA"}