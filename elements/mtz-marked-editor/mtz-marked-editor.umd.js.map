{"version":3,"file":"mtz-marked-editor.umd.js","sources":["mtz-marked-editor.umd.js"],"sourcesContent":["import { html, PolymerElement } from \"@polymer/polymer/polymer-element.js\";\nimport { FlattenedNodesObserver } from \"@polymer/polymer/lib/utils/flattened-nodes-observer.js\";\nimport { IronFormElementBehavior } from \"@polymer/iron-form-element-behavior/iron-form-element-behavior.js\";\nimport { IronValidatableBehavior } from \"@polymer/iron-validatable-behavior/iron-validatable-behavior.js\";\nimport { mixinBehaviors } from \"@polymer/polymer/lib/legacy/class.js\";\n/**\n * `mtz-marked-editor`\n * @element mtz-marked-editor\n * `Creates a textarea with common editor logic and can be controlled by UI elements`\n * @demo demo/index.html\n */\nclass MtzMarkedEditor extends mixinBehaviors(\n  [IronFormElementBehavior, IronValidatableBehavior],\n  PolymerElement\n) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n        }\n      </style>\n      <slot name=\"controls\"></slot> <slot name=\"textarea\"></slot>\n      <slot name=\"footer\"></slot>\n    `;\n  }\n  static get tag() {\n    return \"mtz-marked-editor\";\n  }\n  static get properties() {\n    return {\n      ...super.properties,\n\n      autofocus: Boolean,\n      readonly: Boolean,\n      textareaSelector: {\n        type: String,\n        value: \"textarea\"\n      },\n      __textarea: Object\n    };\n  }\n  constructor() {\n    super();\n    this.addEventListener(\n      \"register-control\",\n      this.__bindControlToEditor.bind(this)\n    );\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.__textarea = this.queryDistributedElements('[slot=\"textarea\"]')[0];\n  }\n  /**\n   * Returns a filtered list of flattened child elements for this element based\n   * on the given selector.\n   *\n   * @param {string} selector Selector to filter nodes against\n   * @return {!Array<!HTMLElement>} List of flattened child elements\n   * @override\n   */\n  queryDistributedElements(selector) {\n    let c$ = FlattenedNodesObserver.getFlattenedNodes(this);\n    let list = [];\n    for (let i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\n      if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {\n        list.push(c);\n      }\n    }\n    return list;\n  }\n\n  disconnectedCallback() {\n    this.removeEventListener(\"register-control\", this.__bindControlToEditor);\n    super.disconnectedCallback();\n  }\n  /**\n   * Returns the instance of textarea\n   * @return {HTMLTextAreaElement}\n   */\n  getTextarea() {\n    return this.__textarea;\n  }\n  /**\n   * Returns the number of lines in the textarea\n   * @return {Number}\n   */\n  getLines() {\n    return this.getContent().split(/(?=\\n|\\r\\n)$/gm);\n  }\n  /**\n   * Gets the content of the textarea\n   * @return {String}\n   */\n  getContent() {\n    if (typeof this.getTextarea() !== typeof undefined) {\n      return this.getTextarea().value;\n    }\n    return \"\";\n  }\n  /**\n   * Sets the content of the textarea\n   * @param {String} content\n   */\n  setContent(content) {\n    this.getTextarea().value = content;\n  }\n  /**\n   * Gets the selection information from the textarea and puts it into\n   * a useful object.\n   * @param {HTMLTextAreaElement} [textarea=this.getTextarea()]\n   * @return {Object} Containing selection information, start, end, text, and length.\n   */\n  getSelection(textarea = this.getTextarea()) {\n    const start = textarea.selectionStart;\n    const end = textarea.selectionEnd;\n    return {\n      start,\n      end,\n      length: end - start,\n      text: textarea.value.substring(start, end)\n    };\n  }\n  /**\n   * Updates the selection of the textarea\n   * @param {Number} start - Starting index of selection\n   * @param {Number} end - Ending index of selection\n   * @param {HTMLTextAreaElement} [textarea=this.getTextarea()]\n   */\n  setSelection(start, end, textarea = this.getTextarea()) {\n    textarea.selectionStart = start;\n    textarea.selectionEnd = end;\n  }\n  /**\n   * Replaces the current selection with the passed in text\n   * @param {String} text\n   * @param {HTMLTextAreaElement} [textarea=this.getTextarea()]\n   * @param {Object} [selection=this.getSelection()]\n   */\n  replaceSelection(\n    text,\n    textarea = this.getTextarea(),\n    selection = this.getSelection()\n  ) {\n    const val = textarea.value;\n    textarea.value = `${val.substr(0, selection.start)}${text}${val.substr(\n      selection.end,\n      val.length\n    )}`;\n  }\n  /**\n   * Adds a reference of editor to the control\n   * @param {CustomEvent} event\n   * @private\n   */\n  __bindControlToEditor(e) {\n    e.stopPropagation();\n    e.target.__editor = this;\n  }\n}\nwindow.customElements.define(MtzMarkedEditor.tag, MtzMarkedEditor);\nexport { MtzMarkedEditor };\n\nconst p = Element.prototype;\n/**\n * @const {function(this:Node, string): boolean}\n */\nconst normalizedMatchesSelector =\n  p.matches ||\n  p.matchesSelector ||\n  p.mozMatchesSelector ||\n  p.msMatchesSelector ||\n  p.oMatchesSelector ||\n  p.webkitMatchesSelector;\n\n/**\n * Cross-platform `element.matches` shim.\n *\n * @function matchesSelector\n * @param {!Node} node Node to check selector against\n * @param {string} selector Selector to match\n * @return {boolean} True if node matched selector\n */\nexport const matchesSelector = function(node, selector) {\n  return normalizedMatchesSelector.call(node, selector);\n};\n"],"names":["MtzMarkedEditor","addEventListener","_this","__bindControlToEditor","bind","mixinBehaviors","IronFormElementBehavior","IronValidatableBehavior","PolymerElement","html","autofocus","Boolean","readonly","textareaSelector","type","String","value","__textarea","Object","this","queryDistributedElements","selector","c","c$","FlattenedNodesObserver","getFlattenedNodes","list","i","l","length","nodeType","Node","ELEMENT_NODE","matchesSelector","push","removeEventListener","getContent","split","_typeof","getTextarea","content","textarea","start","selectionStart","end","selectionEnd","text","substring","selection","getSelection","val","substr","e","stopPropagation","target","__editor","window","customElements","define","tag","p","Element","prototype","normalizedMatchesSelector","matches","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","node","call"],"mappings":"woFAWMA,kOAiCGC,iBACH,mBACAC,EAAKC,sBAAsBC,0PAnCHC,iBAC5B,CAACC,0BAAyBC,2BAC1BC,mEAGSC,8CAWA,wbAMLC,UAAWC,QACXC,SAAUD,QACVE,iBAAkB,CAChBC,KAAMC,OACNC,MAAO,YAETC,WAAYC,uHAYTD,WAAaE,KAAKC,yBAAyB,qBAAqB,oDAU9CC,WAGQC,EAF3BC,EAAKC,yBAAuBC,kBAAkBN,MAC9CO,EAAO,GACFC,EAAI,EAAGC,EAAIL,EAAGM,OAAWF,EAAIC,IAAMN,EAAIC,EAAGI,IAAKA,IAClDL,EAAEQ,WAAaC,KAAKC,cAAgBC,EAAgBX,EAAGD,IACzDK,EAAKQ,KAAKZ,UAGPI,sDAIFS,oBAAoB,mBAAoBhB,KAAKhB,6HAQ3CgB,KAAKF,qDAOLE,KAAKiB,aAAaC,MAAM,2EAO3BC,EAAOnB,KAAKoB,eACPpB,KAAKoB,cAAcvB,MAErB,sCAMEwB,QACJD,cAAcvB,MAAQwB,6CAQhBC,yDAAWtB,KAAKoB,cACrBG,EAAQD,EAASE,eACjBC,EAAMH,EAASI,mBACd,CACLH,MAAAA,EACAE,IAAAA,EACAf,OAAQe,EAAMF,EACdI,KAAML,EAASzB,MAAM+B,UAAUL,EAAOE,yCAS7BF,EAAOE,OAAKH,yDAAWtB,KAAKoB,cACvCE,EAASE,eAAiBD,EAC1BD,EAASI,aAAeD,2CASxBE,OACAL,yDAAWtB,KAAKoB,cAChBS,yDAAY7B,KAAK8B,eAEXC,EAAMT,EAASzB,MACrByB,EAASzB,gBAAWkC,EAAIC,OAAO,EAAGH,EAAUN,eAASI,UAAOI,EAAIC,OAC9DH,EAAUJ,IACVM,EAAIrB,uDAQcuB,GACpBA,EAAEC,kBACFD,EAAEE,OAAOC,SAAWpC,cAGxBqC,OAAOC,eAAeC,OAAO1D,EAAgB2D,IAAK3D,GAGlD,IAAM4D,EAAIC,QAAQC,UAIZC,EACJH,EAAEI,SACFJ,EAAE3B,iBACF2B,EAAEK,oBACFL,EAAEM,mBACFN,EAAEO,kBACFP,EAAEQ,sBAUSnC,EAAkB,SAASoC,EAAMhD,UACrC0C,EAA0BO,KAAKD,EAAMhD"}