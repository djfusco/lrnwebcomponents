{"version":3,"file":"map-menu.umd.js","sources":["map-menu.umd.js"],"sourcesContent":["/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, html, css } from \"lit-element/lit-element.js\";\nimport \"@lrnwebcomponents/map-menu/lib/map-menu-builder.js\";\nimport \"@lrnwebcomponents/map-menu/lib/map-menu-container.js\";\n/**\n * `map-menu`\n * `A series of elements that generate a hierarchical menu`\n *\n * @demo demo/index.html\n * @element map-menu\n */\nclass MapMenu extends LitElement {\n  /**\n   * LitElement constructable styles enhancement\n   */\n  static get styles() {\n    return [\n      css`\n        :host {\n          --map-menu-active-color: rgba(0, 0, 0, 0.1);\n          --map-menu-size: 1;\n          --map-menu-font-size: 16px;\n          display: block;\n          overflow-y: scroll;\n          position: relative;\n          height: 100%;\n          transition: 0.1s linear all;\n          opacity: 1;\n          background-color: transparent;\n        }\n        #itemslist {\n          display: var(--map-menu-items-list-display);\n          flex-direction: var(--map-menu-items-list-flex-direction);\n          flex: var(--map-menu-items-list-flex);\n        }\n        #activeindicator {\n          background: var(--map-menu-active-color);\n          transition: all 0.1s ease-in-out;\n          position: absolute;\n        }\n\n        map-menu-container {\n          padding: var(--map-menu-container-padding, 0);\n          display: var(--map-menu-container-display);\n          flex-direction: var(--map-menu-container-flex-direction);\n          flex: var(--map-menu-container-flex);\n        }\n\n        /* turn default active color if indicator is on */\n        :host([active-indicator]) map-menu-builder {\n          --map-menu-active-color: transparent;\n        }\n      `\n    ];\n  }\n  /**\n   * HTMLElement\n   */\n  constructor() {\n    super();\n    this.disabled = false;\n    this.title = \"Content outline\";\n    this.data = null;\n    this.items = [];\n    this.autoScroll = false;\n    this.activeIndicator = false;\n    setTimeout(() => {\n      this.addEventListener(\n        \"link-clicked\",\n        this.__linkClickedHandler.bind(this)\n      );\n      this.addEventListener(\"toggle-updated\", this.__toggleUpdated.bind(this));\n      this.addEventListener(\"active-item\", this.__activeItemHandler.bind(this));\n      this.addEventListener(\n        \"map-meu-item-hidden-check\",\n        this._mapMeuItemHiddenCheckHandler.bind(this)\n      );\n    }, 0);\n  }\n  /**\n   * LitElement life cycle - render\n   */\n  render() {\n    return html`\n      <div id=\"itemslist\">\n        <map-menu-container>\n          <div id=\"activeindicator\"></div>\n          <map-menu-builder\n            id=\"builder\"\n            .items=\"${this.items}\"\n            .selected=\"${this.selected}\"\n          ></map-menu-builder>\n        </map-menu-container>\n      </div>\n    `;\n  }\n\n  static get tag() {\n    return \"map-menu\";\n  }\n\n  static get properties() {\n    return {\n      disabled: {\n        type: Boolean,\n        reflect: true\n      },\n      title: {\n        type: String\n      },\n      data: {\n        type: Array\n      },\n      /**\n       * Support for JSON Outline Schema manifest format\n       */\n      manifest: {\n        type: Object\n      },\n      items: {\n        type: Array\n      },\n      /**\n       * Current selected item.\n       */\n      selected: {\n        type: String\n      },\n      activeItem: {\n        type: Object\n      },\n      /**\n       * Auto scroll an active element if not in view\n       */\n      autoScroll: {\n        type: Boolean,\n        attribute: \"auto-scroll\"\n      },\n      /**\n       * Show active indicator animation\n       */\n      activeIndicator: {\n        type: Boolean,\n        reflect: true,\n        attribute: \"active-indicator\"\n      }\n    };\n  }\n  /**\n   * LitElement life cycle - properties changed\n   */\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      if (propName == \"data\") {\n        this._dataChanged(this[propName]);\n      }\n      if (propName == \"manifest\") {\n        this._manifestChanged(this[propName]);\n      }\n      if (propName == \"activeItem\") {\n        this.refreshActiveChildren(this[propName], oldValue);\n      }\n      // notify\n      if ([\"manifest\", \"items\", \"selected\"].includes(propName)) {\n        this.dispatchEvent(\n          new CustomEvent(`${propName}-changed`, {\n            detail: {\n              value: this[propName]\n            }\n          })\n        );\n      }\n    });\n  }\n  __activeItemHandler(e) {\n    this.activeItem = e.detail;\n  }\n\n  _mapMeuItemHiddenCheckHandler(e) {\n    const action = e.detail.action;\n    const hiddenChild = e.detail.hiddenChild;\n    if (action === \"closed\" && hiddenChild === true) {\n      this.__updateActiveIndicator(this.activeItem, true);\n    } else {\n      this.__updateActiveIndicator(this.activeItem, false);\n    }\n  }\n\n  /**\n   * Set and unset active properties on children\n   * @param {string} activeItem\n   */\n  refreshActiveChildren(newValue, oldValue) {\n    if (newValue) {\n      // set the new active attribute to the item\n      newValue.setAttribute(\"active\", \"active\");\n      // move the highlight thingy\n      if (this.activeIndicator) {\n        this.__updateActiveIndicator(newValue);\n      }\n      // if auto scroll enabled then scroll element into view\n      if (this.autoScroll) {\n        // kick off smooth scroll\n        this.__scrollHandler(newValue, {\n          duration: 100,\n          scrollElement: this\n        });\n      }\n    }\n\n    if (oldValue) {\n      oldValue.removeAttribute(\"active\");\n      this.__updateActiveIndicator(newValue);\n    }\n  }\n  __scrollHandler(target, options) {\n    // define default options\n    const defaultOptions = {\n      align: \"top\",\n      delay: 0,\n      duration: 300,\n      scrollElement: window\n    };\n    // combine default and user defined options\n    const _options = Object.assign({}, defaultOptions, options);\n    // get the bound client\n    const targetPosition = target.getBoundingClientRect();\n    // get the scroll Element position\n    const scrollElementPosition = _options.scrollElement.getBoundingClientRect();\n    // get the height of the scroll Element\n    const scrollElementHeight =\n      _options.scrollElement.getBoundingClientRect().bottom -\n      _options.scrollElement.getBoundingClientRect().top;\n    // get the height of the element target\n    const targetHeight = targetPosition.bottom - targetPosition.top;\n    // get the offset of the scroll Element\n    const startPosition = _options.scrollElement.scrollTop;\n    // get the distance between the top of the scroll and the top of the bounding rectangles\n    let distance =\n      target.getBoundingClientRect().top -\n      _options.scrollElement.getBoundingClientRect().top;\n    /**\n     * @todo weird trick to position the scroll over the target\n     * I'm still not sure why this works :)\n     */\n    distance = distance - scrollElementHeight / 2;\n    // see where the user wants to align the scroll\n    switch (_options.align) {\n      case \"center\":\n        distance = distance + targetHeight / 2;\n        break;\n      case \"bottom\":\n        distance = distance + targetHeight;\n        break;\n      default:\n        break;\n    }\n    // record start time\n    let startTime = null;\n    // internal animation function\n    function animation(currentTime) {\n      if (startTime === null) startTime = currentTime;\n      let timeElapsed = currentTime - startTime;\n      let run = ease(timeElapsed, startPosition, distance, _options.duration);\n      _options.scrollElement.scrollTop = run;\n      if (timeElapsed < _options.duration) requestAnimationFrame(animation);\n    }\n    // define a ease-in-out\n    function ease(t, b, c, d) {\n      if ((t /= d / 2) < 1) return (c / 2) * t * t + b;\n      return (-c / 2) * (--t * (t - 2) - 1) + b;\n    }\n    // start animation\n    requestAnimationFrame(animation);\n  }\n\n  _manifestChanged(newValue) {\n    if (newValue) {\n      this.data = newValue.items;\n    }\n  }\n  /**\n   * LitElement life cycle - ready\n   */\n  firstUpdated(changedProperties) {\n    if (this.activeItem) {\n      this.refreshActiveChildren(this.activeItem, false);\n    }\n  }\n  /**\n   * Convert data from a linear array\n   * to a nested array for template rendering\n   */\n  _dataChanged(data) {\n    const items = [];\n    if (!data) return;\n    // find parents\n    data.forEach(element => {\n      // find top level parents\n      if (!element.parent) {\n        items.push(element);\n      }\n    });\n    // Recursively find and set children\n    items.forEach((item, i) => {\n      this._setChildren(item, data);\n    });\n    // Update items array\n    this.items = [...items];\n  }\n\n  /**\n   * Recursively search through a data to find children\n   * of a specified item.\n   * @param {object} item item of an array to search on. Passed by reference.\n   * @param {array} data linear array of the data set.\n   * @return {void}\n   */\n  _setChildren(item, data) {\n    // find all children\n    const children = data.filter(d => item.id === d.parent);\n    item.children = children;\n    if (item.children.length > 0) {\n      item.children.forEach(child => {\n        // recursively call itself\n        this._setChildren(child, data);\n      });\n    }\n  }\n\n  /**\n   * Determine if a menu item has children\n   */\n  __hasChildren(item) {\n    return item.children.length > 0;\n  }\n\n  /**\n   * asdf\n   */\n  __linkClickedHandler(e) {\n    this.selected = e.detail.id;\n    this.dispatchEvent(\n      new CustomEvent(\"selected\", {\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n        detail: e.detail.id\n      })\n    );\n  }\n\n  /**\n   * When a user clicks the toggle button to collapse or\n   * expand a submenu, this event gets triggered after\n   * the animation has been triggered\n   */\n  __toggleUpdated(e) {\n    const action = e.detail.opened ? \"opened\" : \"closed\";\n    const target = e.path[0];\n    if (typeof this.activeItem !== \"undefined\") {\n      this.__updateActiveIndicator(this.activeItem, false);\n      this.activeItem.dispatchEvent(\n        new CustomEvent(\"map-menu-item-hidden-check\", {\n          bubbles: true,\n          cancelable: true,\n          composed: true,\n          detail: Object.assign(\n            {},\n            {\n              action: action,\n              target: target\n            }\n          )\n        })\n      );\n    }\n  }\n\n  /**\n   * Find out if\n   */\n  __isInViewport(element) {\n    const scrollParent = this.__getScrollParent(element);\n    if (!scrollParent) return false;\n\n    var elementTop = element.offsetTop;\n    var elementBottom = elementTop + element.offsetHeight;\n    var viewportTop = scrollParent.offsetTop;\n    var viewportBottom = viewportTop + scrollParent.offsetHeight;\n    return elementBottom > viewportTop && elementTop < viewportBottom;\n  }\n\n  /**\n   * Get scroll parent\n   */\n  __getScrollParent(node) {\n    if (node == null) {\n      return null;\n    }\n\n    if (node.scrollHeight > node.clientHeight) {\n      return node;\n    } else {\n      return this.__getScrollParent(node.parentNode);\n    }\n  }\n\n  /**\n   * Move the highlight widget over active element\n   */\n  __updateActiveIndicator(element, hidden = false) {\n    // run it through to set time just to let stuff set up\n    setTimeout(() => {\n      const activeindicator = this.shadowRoot.querySelector(\"#activeindicator\");\n      const left = element.offsetLeft;\n      const top = element.offsetTop;\n      const width = element.offsetWidth;\n      // if the element is hidden the set the indicator height to zero to make it disapear\n      const height = !hidden ? element.offsetHeight : 0;\n      activeindicator.setAttribute(\n        \"style\",\n        `width:${width}px;height:${height}px;top:${top}px;left:${left}px`\n      );\n    }, 200);\n  }\n  /**\n   * Find out if any parents of the item are collapsed\n   */\n  __parentsHidden(node) {\n    // get the parent node\n    const parent = node.parentNode;\n    // bail if we have no node to work with\n    if (parent == null) return null;\n    // if we found a submenu check if it is hidden\n    if (parent.tagName === \"MAP-MENU-SUBMENU\") {\n      // if open is set to false then we have\n      // found a hidden parent\n      if (!parent.opened) return true;\n    }\n    // wrap up and exit if we came all the way back to map-menu\n    if (parent.tagName === \"MAP-MENU\") return false;\n    // if we got all the way here then we need recursively run this\n    // against the parent node\n    return this.__parentsHidden(parent);\n  }\n}\nwindow.customElements.define(MapMenu.tag, MapMenu);\nexport { MapMenu };\n"],"names":["MapMenu","disabled","title","data","items","autoScroll","activeIndicator","setTimeout","addEventListener","_this","__linkClickedHandler","bind","__toggleUpdated","__activeItemHandler","_mapMeuItemHiddenCheckHandler","LitElement","css","html","this","selected","changedProperties","forEach","oldValue","propName","_this2","_dataChanged","_manifestChanged","refreshActiveChildren","includes","dispatchEvent","CustomEvent","detail","value","e","activeItem","action","hiddenChild","__updateActiveIndicator","newValue","setAttribute","__scrollHandler","duration","scrollElement","removeAttribute","target","options","defaultOptions","align","delay","window","_options","Object","assign","targetPosition","getBoundingClientRect","scrollElementHeight","bottom","top","targetHeight","startPosition","scrollTop","distance","startTime","requestAnimationFrame","animation","currentTime","t","b","c","d","timeElapsed","run","element","parent","push","item","i","_this3","_setChildren","children","filter","id","length","child","_this4","bubbles","cancelable","composed","opened","path","scrollParent","__getScrollParent","elementTop","offsetTop","elementBottom","offsetHeight","viewportTop","viewportBottom","node","scrollHeight","clientHeight","parentNode","hidden","activeindicator","_this5","shadowRoot","querySelector","left","offsetLeft","width","offsetWidth","height","tagName","__parentsHidden","type","Boolean","reflect","String","Array","manifest","attribute","customElements","define","tag"],"mappings":"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"}