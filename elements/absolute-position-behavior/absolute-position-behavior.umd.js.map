{"version":3,"file":"absolute-position-behavior.umd.js","sources":["lib/absolute-position-state-manager.js","absolute-position-behavior.umd.js"],"sourcesContent":["/**\n * Copyright 2018 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement } from \"lit-element/lit-element.js\";\n\n// register globally so we can make sure there is only one\nwindow.AbsolutePositionStateManager = window.AbsolutePositionStateManager || {};\n// request if this exists. This helps invoke element existing in dom\n// as well as that there is only one of them. That way we can ensure everything\n// is rendered through same modal\nwindow.AbsolutePositionStateManager.requestAvailability = () => {\n  if (!window.AbsolutePositionStateManager.instance) {\n    window.AbsolutePositionStateManager.instance = document.createElement(\n      \"absolute-position-state-manager\"\n    );\n    let instance = window.AbsolutePositionStateManager.instance;\n    document.body.appendChild(instance);\n  }\n  return window.AbsolutePositionStateManager.instance;\n};\n/**\n * `absolute-position-state-manager`\n * manages state of multiple absolute-positioned elements on a page\n *\n * @element absolute-position-state-manager\n */\nclass AbsolutePositionStateManager extends LitElement {\n  /* REQUIRED FOR TOOLING DO NOT TOUCH */\n\n  /**\n   * Store tag name to make it easier to obtain directly.\n   */\n  static get tag() {\n    return \"absolute-position-state-manager\";\n  }\n\n  // properties available to custom element for data binding\n  static get properties() {\n    return {\n      /**\n       * Stores an array of all elements using manager.\n       */\n      elements: {\n        type: Array\n      },\n      /**\n       * mutation observer\n       */\n      __observer: {\n        type: Object\n      },\n      /**\n       * resize timeout\n       */\n      __timeout: {\n        type: Object\n      }\n    };\n  }\n\n  /**\n   * Makes sure there is a utility ready and listening for elements.\n   */\n  constructor() {\n    super();\n    this.elements = [];\n    this.__timeout = false;\n    this.__observer = new MutationObserver(mutations =>\n      this.checkMutations(mutations)\n    );\n  }\n\n  /**\n   * Loads element into array\n   * @param {object} element to be added\n   */\n  loadElement(el) {\n    //only have event listeners when there are elements using manager\n    if (this.elements.length < 1) {\n      this.__observer.observe(document, {\n        attributes: true,\n        childList: true,\n        subtree: true,\n        characterData: true\n      });\n      this.updateElements();\n      document.addEventListener(\"load\", this.updateElements);\n      window.addEventListener(\"resize\", this._handleResize);\n    }\n    this.elements.push(el);\n    el.style.top = 0;\n    el.style.left = 0;\n    this.positionElement(el);\n  }\n\n  /**\n   * Unloads element from array\n   * @param {object} element to be removed\n   */\n  unloadElement(el) {\n    this.elements.filter(element => element === el);\n    if (this.elements.length < 1) this.removeEventListeners();\n  }\n\n  /**\n   * handles resize event\n   */\n  _handleResize() {\n    if (this.__timeout) clearTimeout(this.__timeout);\n    this.__timeout = setTimeout(\n      window.AbsolutePositionStateManager.instance.updateElements(),\n      250\n    );\n  }\n\n  /**\n   * Checks if there are any chances other than to\n   * element's position and updates accordioning.\n   * This is needed so that positioning elements\n   * doesn't trigger an infinite loop of updates.\n   *\n   * @param {array} mutation records\n   * @return {void}\n   */\n  checkMutations(mutations) {\n    let update = false;\n\n    mutations.forEach(mutation => {\n      if (update) return;\n      update =\n        update ||\n        !(\n          mutation.type === \"attributes\" &&\n          mutation.attributeName === \"style\" &&\n          this.elements.includes(mutation.target)\n        );\n    });\n    if (update) this.updateElements();\n  }\n\n  /**\n   * Returns target element that this element is anchored to. It is\n   * either element given by `for` attribute, or immediate parent\n   * of element.\n   *\n   * Uses `target` object if specified.\n   * If not, queries document for elements with id specified in `for` attribute.\n   * If there is more than one element that matches, gets closest matching element.\n   *\n   * @param {object} element using absolute-position behavior\n   * @return {object} target element for positioning\n   */\n  findTarget(el) {\n    let selector = \"#\" + el.for,\n      target = el.target,\n      ancestor = el;\n\n    while (\n      el.for !== undefined &&\n      target === null &&\n      ancestor !== null &&\n      ancestor !== document\n    ) {\n      ancestor = ancestor.parentNode;\n      if (ancestor.nodeType === 11) ancestor = ancestor.host;\n      target = ancestor ? ancestor.querySelector(selector) : null;\n    }\n    return target;\n  }\n\n  /**\n   * Removes event listeners\n   * @return {void}\n   */\n  removeEventListeners() {\n    if (this.__observer && this.__observer.disconnect)\n      this.__observer.disconnect();\n    document.removeEventListener(\"load\", this.updateElements);\n    window.removeEventListener(\"resize\", this._handleResize);\n  }\n\n  /**\n   * Updates position for all elements on page.\n   * @return {void}\n   */\n  updateElements() {\n    this.elements.forEach(element => this.positionElement(element));\n  }\n\n  _getParentNode(node) {\n    let parent = node.parentNode;\n    if (\n      parent !== undefined &&\n      parent !== null &&\n      parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE\n    ) {\n      parent = parent.host;\n    }\n    return parent;\n  }\n\n  /**\n   * Gets an updated position based on target.\n   * @param {object} element using absolute-position behavior\n   * @return {void}\n   */\n  positionElement(el) {\n    let target = this.findTarget(el),\n      parent = el.offsetParent;\n    if (!target || !parent) return;\n    let offset = parseFloat(el.offset),\n      w = document.body.getBoundingClientRect(),\n      p = parent.getBoundingClientRect(),\n      t = target.getBoundingClientRect(),\n      e = el.getBoundingClientRect(),\n      //place element before vertically?\n      vertical = (pos = el.position) => pos !== \"left\" && pos !== \"right\",\n      //place element before target?\n      before = (pos = el.position) => pos === \"left\" || pos === \"top\",\n      /**\n       * aligns horizontally if position is vertical\n       * or aligns vertically if position is horizontal\n       */\n      setAlign = (v = vertical(el.position)) => {\n        //fits element within parent's boundaries\n        let pxToNum = px => parseFloat(px.replace(\"px\", \"\")),\n          min = v\n            ? pxToNum(el.style.left) - e.left\n            : pxToNum(el.style.top) - e.top,\n          startAt = v ? \"left\" : \"top\",\n          distance = rect => (v ? rect.width : rect.height),\n          max = min + distance(w) - distance(e),\n          align = min;\n        if (el.positionAlign === \"end\") {\n          align += t[startAt] - distance(e) + distance(t);\n        } else if (el.positionAlign === \"start\") {\n          align += t[startAt];\n        } else {\n          align += t[startAt] - distance(e) / 2 + distance(t) / 2;\n        }\n        return el.fitToVisibleBounds\n          ? Math.max(min, Math.min(max, align)) + \"px\"\n          : align + \"px\"; //if element size > parent, align where parent begins\n      },\n      getCoord = (pos = el.position) => {\n        let pxToNum = px => parseFloat(px.replace(\"px\", \"\")),\n          adjust = vertical(pos)\n            ? pxToNum(el.style.top) - e.top\n            : pxToNum(el.style.left) - e.left;\n        return pos === \"top\"\n          ? t.top + adjust - e.height - offset + \"px\"\n          : pos === \"left\"\n          ? t.left + adjust - e.width - offset + \"px\"\n          : t[pos] + adjust + offset + \"px\";\n      },\n      isFit = (pos = el.position) => {\n        //determines if room for element between parent and target\n        let distance = rect =>\n          vertical(pos) ? e.height + offset : e.width + offset;\n        return before(pos)\n          ? t[pos] - w[pos] > distance\n          : w[pos] - t[pos] > distance; //if no room, return original position\n      },\n      flip = el.fitToVisibleBounds !== false && !isFit(el.position),\n      flipData = {\n        top: [\"bottom\", \"left\", \"right\"],\n        left: [\"right\", \"top\", \"bottom\"],\n        bottom: [\"top\", \"right\", \"left\"],\n        right: [\"left\", \"bottom\", \"top\"]\n      };\n    el.style.position = \"absolute\";\n    /*\n     * fits element according to specified postion,\n     * or finds an alternative position that fits\n     */\n    if (flip && isFit(flipData[el.position][0])) {\n      el.position = flipData[el.position][0];\n    } else if (flip && isFit(flipData[el.position][1])) {\n      el.position = flipData[el.position][1];\n    } else if (flip && isFit(flipData[el.position][2])) {\n      el.position = flipData[el.position][2];\n    } else {\n      el.style.top = vertical(el.position) ? getCoord() : setAlign();\n      el.style.left = vertical(el.position) ? setAlign() : getCoord();\n      //provide positions for element and target (in case furthor positioning adjustments are needed)\n      el.__positions = {\n        self: e,\n        parent: p,\n        target: t\n      };\n    }\n  }\n\n  /**\n   * life cycle, element is removed from DOM\n   */\n  disconnectedCallback() {\n    this.removeEventListeners();\n    super.disconnectedCallback();\n  }\n}\nwindow.customElements.define(\n  AbsolutePositionStateManager.tag,\n  AbsolutePositionStateManager\n);\nexport { AbsolutePositionStateManager };\n","/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, html, css } from \"lit-element/lit-element.js\";\nimport \"./lib/absolute-position-state-manager\";\n\n/**\n * `absolute-position-behavior`\n * abstracts absolute positioning behavior to be resusable in other elements\n * @demo ./demo/index.html\n * @element absolute-position-behavior\n */\nclass AbsolutePositionBehavior extends LitElement {\n  \n  //styles function\n  static get styles() {\n    return  [\n      \n      css`\n:host {\n  display: inline-block;\n  z-index: 99999999;\n  position: absolute;\n}\n\n:host([hidden]) {\n  display: none;\n}\n      `\n    ];\n  }\n  // render function\n  render() {\n    return html`\n\n<slot></slot>`;\n  }\n\n  // properties available to the custom element for data binding\n    static get properties() {\n    return {\n  \n  ...super.properties,\n  \n  /**\n   * Element is positioned from connected to disconnected?\n   * Otherwise setPosition and unsetPosition must be called manually.\n   */\n  \"auto\": {\n    \"type\": Boolean,\n    \"attribute\": \"auto\"\n  },\n  /**\n   * If true, no parts of the tooltip will ever be shown offscreen.\n   */\n  \"fitToVisibleBounds\": {\n    \"type\": Boolean,\n    \"attribute\": \"fit-to-visible-bounds\"\n  },\n  /**\n   * If true, no parts of the tooltip will ever be shown offscreen.\n   */\n  \"hidden\": {\n    \"type\": Boolean,\n    \"attribute\": \"hidden\"\n  },\n  /**\n   * The id of the element that the tooltip is anchored to. This element\n   * must be a sibling of the tooltip. If this property is not set,\n   * then the tooltip will be centered to the parent node containing it.\n   */\n  \"for\": {\n    \"type\": String,\n    \"attribute\": \"for\",\n    \"reflect\": true\n  },\n  /**\n   * The spacing between the top of the tooltip and the element it is\n   * anchored to.\n   */\n  \"offset\": {\n    \"type\": Number,\n    \"attribute\": \"offset\"\n  },\n  /**\n   * Positions the tooltip to the top, right, bottom, left of its content.\n   */\n  \"position\": {\n    \"type\": String,\n    \"attribute\": \"position\",\n    \"reflect\": true\n  },\n  /**\n   * Aligns at the start, or end fo target. Default is centered.\n   */\n  \"positionAlign\": {\n    \"type\": String,\n    \"attribute\": \"position-align\",\n    \"reflect\": true\n  },\n  /**\n   * The actual target element\n   */\n  \"target\": {\n    \"type\": Object\n  },\n  /**\n   * The element's style\n   */\n  \"__positions\": {\n    \"type\": Object\n  }\n}\n;\n  }\n\n  /**\n   * Store tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"absolute-position-behavior\";\n  }\n\n  constructor() {\n    super();\n    this.auto = false;\n    this.fitToVisibleBounds = false;\n    this.for = null;\n    this.offset = 0;\n    this.position = \"bottom\";\n    this.target = null;\n    this.__positions = {};\n    this.__observe = false;\n    this.__manager = window.AbsolutePositionStateManager.requestAvailability();\n  }\n\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      if (propName === \"auto\" && this.auto) this.setPosition();\n      if (propName === \"auto\" && !this.auto) this.unsetPosition();\n      if (propName === \"fitToVisibleBounds\") this.updatePosition();\n      if (propName === \"for\") this.updatePosition();\n      if (propName === \"offset\") this.updatePosition();\n      if (propName === \"position\") this.updatePosition();\n      if (propName === \"positionAlign\") this.updatePosition();\n      if (propName === \"target\") this.updatePosition();\n      if (propName === \"hidden\") this.updatePosition();\n    });\n  }\n\n  /**\n   * Registers element with AbsolutePositionStateManager\n   * @returns {void}\n   */\n  setPosition() {\n    this.__observe = true;\n    this.__manager.loadElement(this);\n  }\n\n  /**\n   * Unregisters element with AbsolutePositionStateManager\n   * @returns {void}\n   */\n  unsetPosition() {\n    this.__observe = false;\n    this.__manager.unloadElement(this);\n  }\n\n  /**\n   * Updates  element's position\n   * @returns {void}\n   */\n  updatePosition() {\n    if (this.__observe === true) {\n      this.__manager.positionElement(this);\n    }\n  }\n  /**\n   * life cycle, element is removed from DOM\n   * @returns {void}\n   */\n  disconnectedCallback() {\n    this.unsetPosition();\n    super.disconnectedCallback();\n  }\n}\nwindow.customElements.define(\n  AbsolutePositionBehavior.tag,\n  AbsolutePositionBehavior\n);\nexport { AbsolutePositionBehavior };\n"],"names":["window","AbsolutePositionStateManager","requestAvailability","instance","document","createElement","body","appendChild","elements","__timeout","__observer","MutationObserver","mutations","_this","checkMutations","LitElement","type","Array","Object","el","this","length","observe","attributes","childList","subtree","characterData","updateElements","addEventListener","_handleResize","push","style","top","left","positionElement","filter","element","removeEventListeners","clearTimeout","setTimeout","update","forEach","mutation","attributeName","_this2","includes","target","selector","ancestor","undefined","parentNode","nodeType","host","querySelector","disconnect","removeEventListener","_this3","node","parent","Node","DOCUMENT_FRAGMENT_NODE","findTarget","offsetParent","offset","parseFloat","w","getBoundingClientRect","p","t","e","vertical","pos","position","setAlign","v","pxToNum","px","replace","min","startAt","distance","rect","width","height","max","align","positionAlign","fitToVisibleBounds","Math","getCoord","adjust","isFit","before","flip","flipData","bottom","right","__positions","self","customElements","define","tag","AbsolutePositionBehavior","auto","__observe","__manager","html","css","Boolean","String","Number","changedProperties","oldValue","propName","setPosition","unsetPosition","updatePosition","loadElement","unloadElement"],"mappings":"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"}